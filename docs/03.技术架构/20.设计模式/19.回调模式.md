---
title: 回调模式
date: 2022-04-11 22:09:52
permalink: /pages/7a6da23431/
titleTag: 原创
categories: 
  - 技术架构
  - 设计模式
tags: 
  - 
---
## 说明
23中设计模式中是没有回调模式的，这里只是一个叫法。

## 创建Bootstrap
```java 
@Builder
public class Bootstrap {

    private Object param;

    private Worker worker;

    private Listener listener;

    public Object getParam() {
        return param;
    }

    public void setParam(Object param) {
        this.param = param;
    }

    public Worker getWorker() {
        return worker;
    }

    public void setWorker(Worker worker) {
        this.worker = worker;
    }

    public Listener getListener() {
        return listener;
    }

    public void setListener(Listener listener) {
        this.listener = listener;
    }

    public void addListener(Listener listener) {
        this.listener = listener;
    }


    public Bootstrap doWork() {
        Object param = worker.action(this.param);
        listener.result(param);
        return this;
    }

}
```

## 创建监听器
```java  
public interface Listener {
    void result(Object resultValue);
}

```
## 创建工作者
```java 
public interface Worker {
    String action(Object param);
}

```
## 创建包装者
```java 
public class Wrapper {
    private Object param;
    private Worker worker;
    private Listener listener;

    public Object getParam() {
        return param;
    }

    public void setParam(Object param) {
        this.param = param;
    }

    public Worker getWorker() {
        return worker;
    }

    public void setWorker(Worker worker) {
        this.worker = worker;
    }

    public Listener getListener() {
        return listener;
    }

    public void addListener(Listener listener) {
        this.listener = listener;
    }
}
```

##  带回调 带超时时间的异步任务 写法模仿 netty
```java  

/**
 * @program: spring-test
 * @ClassName Test
 * @description: 带回调 带超时时间的异步任务 写法模仿 netty
 * @author: sizegang
 * @create: 2022-01-22 23:29
 * @Version 1.0
 **/
public class Test {

    public static void main(String[] args) {
        // 创建 worker
        Worker worker = new Worker() {
            @Override
            public String action(Object param) {
                System.out.println("do workering param " + param);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                return " this is worker result";
            }
        };

        // 添加到bootstrap中
        Bootstrap bootstrap = Bootstrap.builder().param("哈哈哈哈哈").worker(worker).build();

        // 添加监听器
        bootstrap.addListener((x) -> {
            System.out.println(" 执行 listner " + x);
        });
        // 异步执行任务
        CompletableFuture<Bootstrap> future = CompletableFuture.supplyAsync(() -> bootstrap.doWork());
        try {
            future.get(800, TimeUnit.MILLISECONDS);
        } catch (Exception e) {
            // 异常回调
            System.out.println("执行异常" + e);
            bootstrap.getListener().result("超时 ｜ 异常");
        }
    }

}

```
##  带回调 带超时时间的异步任务
```java  

/**
 * @program: spring-test
 * @ClassName BootstrapNew
 * @description: 带回调 带超时时间的异步任务
 * @author: sizegang
 * @Version 1.0
 **/
public class Test1 {

    public static void main(String[] args) {
        Test1 bootstrap = new Test1();

        Worker worker = bootstrap.newWorker();

        Wrapper wrapper = new Wrapper();
        wrapper.setWorker(worker);
        wrapper.setParam("hello");
        //添加结果回调器
        wrapper.addListener(new Listener() {
            @Override
            public void result(Object result) {
                System.out.println(result);
            }
        });

        CompletableFuture future = CompletableFuture.supplyAsync(() -> bootstrap.doWork(wrapper));
        try {
            future.get(800, TimeUnit.MILLISECONDS);
        } catch (InterruptedException | TimeoutException | ExecutionException e) {
            //超时了
            wrapper.getListener().result("time out exception");
        }

    }

    private Wrapper doWork(Wrapper wrapper) {

        Worker worker = wrapper.getWorker();
        String result = worker.action(wrapper.getParam());
        wrapper.getListener().result(result);

        return wrapper;
    }

    private Worker newWorker() {
        return new Worker() {
            @Override
            public String action(Object object) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                return object + " world";
            }
        };
    }

}
```
## 一个带回调的异步任务
```java 
public class Test2 {

    public static void main(String[] args) {
        Test2 test2 = new Test2();

        Worker worker = test2.newWorker();
        // 这里的wrapper 和 netty中的ChannelFuture 和  ChannelPromise 类似
        Wrapper wrapper = new Wrapper();
        //
        wrapper.setWorker(worker);
        wrapper.setParam("hello");
        // todo 如果action 执行时间小于1 ms 会空指针异常   可以先添加 listener 再 doWorker
        test2.doWork(wrapper).addListener(new Listener() {
            @Override
            public void result(Object result) {
                System.out.println(Thread.currentThread().getName());
                System.out.println(result);
            }
        });


        System.out.println(Thread.currentThread().getName());

    }

    private Wrapper doWork(Wrapper wrapper) {
        new Thread(() -> {
            Worker worker = wrapper.getWorker();
            String result = worker.action(wrapper.getParam());
            wrapper.getListener().result(result);
        }).start();

        return wrapper;
    }

    private Worker newWorker() {
        return new Worker() {
            @Override
            public String action(Object object) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                return object + " world";
            }
        };

    }
}

```
