---
title: 处理链模式三
date: 2022-03-07 22:09:52
permalink: /pages/76c1e11/
titleTag: 原创
categories: 
  - 技术架构
  - 设计模式
tags: 
  - 
---
  
## 背景
日志级别分为 info、debug、error
那么如何通过责任链模式实现一套 控制日志打印级别的程序呢？


## 责任链业务
```java 
@Data
@AllArgsConstructor
public class ChainBusiness {

    public int level;// 处理级别

    public String businessType;// 处理时间类型

}

```

## 辅助实体
```java 
public class Constant {
    public static class ChainEnum {
        public static final int INFO = 1;//一级处理级别
        public static final int DEBUG = 2;//二级处理级别
        public static final int ERROR = 3;//三级处理级别
    }
}

```

##  抽象责任链
```java  
public abstract class Handler {

    protected int level;//默认一级处理级别

    public Handler(int level) {
        this.level = level;
    }

    private Handler nextHandler;//下一个处理器

    //获取下一个责任链
    public Handler getNextHandler() {
        return nextHandler;
    }

    //设置下一个责任链
    public void setNextHandler(Handler handler) {
        this.nextHandler = handler;
    }

    abstract protected void handle(ChainBusiness chainBusiness);//真正的处理逻辑在父类中不做处理，在子类中做处理

    //处理功能，判断是否存在处理链，如果存在则交由下一个处理链处理
    ///传入处理级别，设计责任链逻辑
    public void execute(ChainBusiness chainBusiness) {
        if (this.level <= chainBusiness.getLevel()) {//如果处理级别大于当前处理器的处理级别，那么全部处理
            //这里是不同的处理器的处理方法，
            //execute方法是公共的设计方法，具体的处理逻辑在每个处理器当中
            this.handle(chainBusiness);
        }
        if (nextHandler != null) {
            nextHandler.execute(chainBusiness);
        }
    }
}
```


## 抽象责任链
```java  

/**
 * @program: spring-test
 * @ClassName AbstractHandler
 * @description: 抽象责任链处理器
 * * 1. 参数校验 2. 用户名密码校验 3. 权限校验
 * @author: sizegang
 * @create: 2022-01-01 00:41
 * @Version 1.0
 **/
public abstract class AbstractLoginExecutor<T> implements LoginChain {

    protected Chain chain;

    public void next(Chain chain) {
        this.chain = chain;
    }

    // 这里结合模板方法
    @Override
    public void execute(Member member) {
        doExecute(member);
    }
    /**
     * 责任链模式配合建造者模式
     *
     * @param <T>
     */
    public static class Builder<T> {
        private AbstractLoginExecutor<T> head;
        private AbstractLoginExecutor<T> tail;

        public Builder<T> addChain(AbstractLoginExecutor<T> handler) {
            if (this.head == null) {
                this.head = this.tail = handler;
                return this;
            }
            // 设置自身的下一个节点
            this.tail.next(handler);
            // 修改指针指向
            this.tail = handler;
            return this;
        }

        public AbstractLoginExecutor<T> build() {
            return this.head;
        }

    }
}
```
## INFO 责任链
```java  
@Slf4j
public class InfoHandler extends Handler {
    public InfoHandler(int level) {
        super(level);
    }

    @Override
    protected void handle(ChainBusiness chainBusiness) {
        log.info("我是info处理器,处理{}", chainBusiness.getBusinessType());
    }
}
```

```

## DEBUG 责任链
```java 
@Slf4j
public class DebuggerHandler extends Handler {
    public DebuggerHandler(int level) {
        super(level);
    }

    @Override
    protected void handle(ChainBusiness chainBusiness) {
        log.info("我是debugger处理器, 处理{}", chainBusiness.getBusinessType());
    }
}

```

## ERROR责任链
```java  
@Slf4j
public class ErrorHandler extends Handler {
    public ErrorHandler(int level) {
        super(level);
    }
    @Override
    protected void handle(ChainBusiness chainBusiness) {
        log.info("我是error处理器, 处理{}", chainBusiness.getBusinessType());
    }
}

```

## 用户登陆服务
```java  
public class LoginAssembler {
    /**
     * 会员等六
     * @param member 会员
     */
    public void login(Member member){
        AbstractLoginExecutor.Builder builder = new AbstractLoginExecutor.Builder();
        AbstractLoginExecutor build = builder.addChain(new ValidateExecutor()).addChain(new LoginExecutor()).addChain(new AuthHandler()).build();
        build.execute(member);
    }
}
```
## 责任链构建器
```java  
public class RuleHandler {
    public static Handler initChain() {
        InfoHandler infoHandler = new InfoHandler(Constant.ChainEnum.INFO);
        DebuggerHandler debuggerHandler = new DebuggerHandler(Constant.ChainEnum.DEBUG);
        ErrorHandler errorHandler = new ErrorHandler(Constant.ChainEnum.ERROR);
        infoHandler.setNextHandler(debuggerHandler);
        debuggerHandler.setNextHandler(errorHandler);
        return infoHandler;
    }
}

## 测试
```java  
public class Test {
    public static void main(String[] args) {
        Handler handler = RuleHandler.initChain();//初始化处理链
        /*handler.execute(1, "哈哈哈哈");处理链一，只执行处理链一的内容*/
        ChainBusiness chainBusiness = new ChainBusiness(Constant.ChainEnum.DEBUG, "debugger");
        handler.execute(chainBusiness);
    }
}

```
